# -*- coding: utf-8 -*-
"""clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hvaX4hhX4zP7PJJCfwHHZA2Oa3qw-ghs
"""

import numpy as np

with open('/content/drive/MyDrive/spectralnew.txt') as  f:
    X = []
    for line in f:
        cordinates = list(map(int, line.strip().split(',')))
        X.append(cordinates)

X = np.array(X)

X[:10]

import matplotlib.pyplot as plt

X[:400]

plt.scatter(X[:,1] , X[:,0] )

from sklearn.metrics import pairwise_distances

similarity_matrix = pairwise_distances(X, metric="euclidean")
print(similarity_matrix , similarity_matrix.shape)

threshold = 77
adjacency_matrix = []
for i in range(len(similarity_matrix)):
    row = []
    for j in range(len(similarity_matrix)):
        if similarity_matrix[i][j] < threshold:
            row.append(1)
        else:
            row.append(0)
    adjacency_matrix.append(row)

adjacency_matrix = np.array(adjacency_matrix)
adjacency_matrix

degree_matrix = []
for i in range(len(adjacency_matrix)):
    degree = 0
    for j in range(len(adjacency_matrix)):
        if adjacency_matrix[i][j] ==1:
            degree +=1
    degree_matrix.append(degree)
#print(degree_matrix)       
degree_matrix = np.diag(degree_matrix)
degree_matrix

laplacian = degree_matrix - adjacency_matrix
laplacian

eigen_values, eigen_vectors = np.linalg.eig(laplacian)
# eigenvalues
print('eigenvalues:')
print(eigen_values)
# eigenvectors
print('eigenvectors:')
print(eigen_vectors)

eigen_values = eigen_values.astype(float)
eigen_vectors = eigen_vectors.astype(float)

eigen_vectors.shape

fig = plt.figure(figsize=[18, 6])
ax1 = plt.subplot(121)
plt.plot(eigen_values)
plt.savefig('eigen_values')

sorted_eval = np.argsort(eigen_values)
eigen_values=eigen_values[sorted_eval]
eigen_values[: 120]



sorted_eval

plt.plot(eigen_values)
plt.savefig('eigen_values_sorted')

top_k_eigen_vec = eigen_vectors[: ,sorted_eval[:7]]

top_k_eigen_vec.shape

from sklearn.cluster import KMeans

km = KMeans(init='k-means++', n_clusters=7)
labels = km.fit_predict(top_k_eigen_vec)

labels

plt.scatter(X[:,1] , X[:,0] , c = labels , cmap= 'rainbow')

plt.savefig('predicted_clusters')